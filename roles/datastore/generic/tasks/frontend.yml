---
- ansible.builtin.import_tasks:
    file: "{{ role_path }}/tasks/_init.yml"

- ansible.builtin.include_role:
    name: opennebula/leader
  when: leader is undefined

- delegate_to: "{{ leader }}"
  run_once: true
  block:
    - name: Get Datastores
      ansible.builtin.shell:
        cmd: onedatastore list --json
        executable: /bin/bash
      changed_when: false
      register: shell

    - name: Parse Datastores
      ansible.builtin.set_fact:
        ds_names_parsed: >-
          {{ _names }}
        ds_dict_parsed: >-
          {{ dict(_names | zip(_datastores)) }}
      vars:
        _document: >-
          {{ shell.stdout | from_json }}
        _datastores: >-
          {{ [_document.DATASTORE_POOL.DATASTORE | d([])] | flatten }}
        _names: >-
          {{ _datastores | map(attribute='NAME') | d([]) | list }}

    # NOTE: Only "system" datastores can be enabled or disabled.
    - name: Update Datastores
      ansible.builtin.shell:
        cmd: |
          set -o errexit -o pipefail
          {% if ds_dict[item].enabled is defined %}
          onedatastore {{ 'enable' if ds_dict[item].enabled else 'disable' }} '{{ ds_dict[item].id }}'
          {% endif %}
          set +o errexit
          TEMPLATE="$(mktemp)"
          tee "$TEMPLATE"
          cat "$TEMPLATE" | onedatastore update '{{ ds_dict[item].id }}' "$TEMPLATE"; RC="$?"
          rm -f "$TEMPLATE"
          exit "$RC"
        stdin: |
          {{ _combined | opennebula.deploy.to_one }}
        executable: /bin/bash
      changed_when: true
      when:
        - ds_dict[item].id is defined
        - (_combined | opennebula.deploy.to_one != ds_dict_parsed[item].TEMPLATE | opennebula.deploy.to_one)
          or
          (ds_dict[item].enabled is defined and (ds_dict[item].enabled != (ds_dict_parsed[item].STATE | int == 0)))
      loop: "{{ _existing }}"
      vars:
        _existing: >-
          {{ ds_names | select('in', ds_names_parsed) }}
        _combined: >-
          {{ ds_dict_parsed[item].TEMPLATE | combine(ds_dict[item].template, recursive=true) }}

    - name: Create Datastores
      ansible.builtin.shell:
        cmd: |
          set +o errexit -o pipefail
          TEMPLATE="$(mktemp)"
          tee "$TEMPLATE"
          cat "$TEMPLATE" | onedatastore create "$TEMPLATE"; RC="$?"
          rm -f "$TEMPLATE"
          exit "$RC"
        stdin: |
          {{ ds_dict[item].template | combine({"NAME": item}) | opennebula.deploy.to_one }}
        executable: /bin/bash
      changed_when: true
      loop: "{{ _missing }}"
      register: shell_create_datastores
      vars:
        _missing: >-
          {{ ds_names | reject('in', ds_names_parsed) }}

    - name: Merge back datastore IDs into ds_dict
      ansible.builtin.set_fact:
        ds_dict: >-
          {{ ds_dict | combine(_update1, _update2, recursive=true) }}
      vars:
        # IDs can be sourced either from initial parse or immediately after new datastores are created.
        _update1: >-
          {%- set output = [] -%}
          {%- for item in ds_dict_parsed.items() -%}
          {{- output.append([item.0, {"id": item.1.ID | int}]) -}}
          {%- endfor -%}
          {{- dict(output) -}}
        _update2: >-
          {%- set output = [] -%}
          {%- for item in shell_create_datastores.results -%}
          {{- output.append([item.item, {"id": item.stdout_lines[-1].split(':')[-1] | trim | int}]) -}}
          {%- endfor -%}
          {{- dict(output) -}}

- ansible.builtin.import_tasks:
    file: "{{ role_path }}/tasks/_link.yml"
